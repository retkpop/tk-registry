{"remainingRequest":"/Volumes/TamKieu/java/tk-registry/node_modules/thread-loader/dist/cjs.js??ref--9-2!/Volumes/TamKieu/java/tk-registry/node_modules/ts-loader/index.js??ref--9-3!/Volumes/TamKieu/java/tk-registry/node_modules/angular-router-loader/src/index.js!/Volumes/TamKieu/java/tk-registry/node_modules/tslint-loader/index.js!/Volumes/TamKieu/java/tk-registry/src/main/webapp/app/shared/alert/alert-error.component.ts","dependencies":[{"path":"/Volumes/TamKieu/java/tk-registry/src/main/webapp/app/shared/alert/alert-error.component.ts","mtime":1564500078625},{"path":"/Volumes/TamKieu/java/tk-registry/node_modules/angular2-template-loader/index.js","mtime":1486570058000},{"path":"/Volumes/TamKieu/java/tk-registry/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Volumes/TamKieu/java/tk-registry/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Volumes/TamKieu/java/tk-registry/node_modules/ts-loader/index.js","mtime":1545640398000},{"path":"/Volumes/TamKieu/java/tk-registry/node_modules/angular-router-loader/src/index.js","mtime":1512749902000},{"path":"/Volumes/TamKieu/java/tk-registry/node_modules/tslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nvar _a, _b;\nconst core_1 = require(\"@angular/core\");\nconst ng_jhipster_1 = require(\"ng-jhipster\");\nlet JhiAlertErrorComponent = class JhiAlertErrorComponent {\n    constructor(alertService, eventManager) {\n        this.alertService = alertService;\n        this.eventManager = eventManager;\n        this.alerts = [];\n        this.cleanHttpErrorListener = eventManager.subscribe('jHipsterRegistryApp.httpError', response => {\n            let i;\n            const httpErrorResponse = response.content;\n            switch (httpErrorResponse.status) {\n                // connection refused, server not reachable\n                case 0:\n                    this.addErrorAlert('Server not reachable', 'error.server.not.reachable');\n                    break;\n                case 400:\n                    const arr = httpErrorResponse.headers.keys();\n                    let errorHeader = null;\n                    let entityKey = null;\n                    arr.forEach(entry => {\n                        if (entry.endsWith('app-error')) {\n                            errorHeader = httpErrorResponse.headers.get(entry);\n                        }\n                        else if (entry.endsWith('app-params')) {\n                            entityKey = httpErrorResponse.headers.get(entry);\n                        }\n                    });\n                    if (errorHeader) {\n                        const entityName = entityKey;\n                        this.addErrorAlert(errorHeader, errorHeader, { entityName });\n                    }\n                    else if (httpErrorResponse.error !== '' && httpErrorResponse.error.fieldErrors) {\n                        const fieldErrors = httpErrorResponse.error.fieldErrors;\n                        for (i = 0; i < fieldErrors.length; i++) {\n                            const fieldError = fieldErrors[i];\n                            // convert 'something[14].other[4].id' to 'something[].other[].id' so translations can be written to it\n                            const convertedField = fieldError.field.replace(/\\[\\d*\\]/g, '[]');\n                            const fieldName = convertedField.charAt(0).toUpperCase() + convertedField.slice(1);\n                            this.addErrorAlert('Field ' + fieldName + ' cannot be empty', 'error.' + fieldError.message, { fieldName });\n                        }\n                    }\n                    else if (httpErrorResponse.error !== '' && httpErrorResponse.json() && httpErrorResponse.error.message) {\n                        this.addErrorAlert(httpErrorResponse.error.message, httpErrorResponse.error.message, httpErrorResponse.error.params);\n                    }\n                    else {\n                        this.addErrorAlert(httpErrorResponse.error);\n                    }\n                    break;\n                case 404:\n                    this.addErrorAlert('Not found', 'error.url.not.found');\n                    break;\n                default:\n                    if (httpErrorResponse.error !== '' && httpErrorResponse.error.message) {\n                        this.addErrorAlert(httpErrorResponse.error.message);\n                    }\n                    else {\n                        this.addErrorAlert(httpErrorResponse.error);\n                    }\n            }\n        });\n    }\n    ngOnDestroy() {\n        if (this.cleanHttpErrorListener !== undefined && this.cleanHttpErrorListener !== null) {\n            this.eventManager.destroy(this.cleanHttpErrorListener);\n            this.alerts = [];\n        }\n    }\n    addErrorAlert(message, key, data) {\n        this.alerts.push(this.alertService.addAlert({\n            type: 'danger',\n            msg: message,\n            timeout: 5000,\n            toast: this.alertService.isToast(),\n            scoped: true\n        }, this.alerts));\n    }\n};\nJhiAlertErrorComponent = tslib_1.__decorate([\n    core_1.Component({\n        selector: 'jhi-alert-error',\n        template: `\n        <div class=\"alerts\" role=\"alert\">\n            <div *ngFor=\"let alert of alerts\"  [ngClass]=\"{\\'alert.position\\': true, \\'toast\\': alert.toast}\">\n                <ngb-alert *ngIf=\"alert && alert.type && alert.msg\" type=\"{{alert.type}}\" close=\"alert.close(alerts)\">\n                    <pre [innerHTML]=\"alert.msg\"></pre>\n                </ngb-alert>\n            </div>\n        </div>`\n    }),\n    tslib_1.__metadata(\"design:paramtypes\", [typeof (_a = typeof ng_jhipster_1.JhiAlertService !== \"undefined\" && ng_jhipster_1.JhiAlertService) === \"function\" ? _a : Object, typeof (_b = typeof ng_jhipster_1.JhiEventManager !== \"undefined\" && ng_jhipster_1.JhiEventManager) === \"function\" ? _b : Object])\n], JhiAlertErrorComponent);\nexports.JhiAlertErrorComponent = JhiAlertErrorComponent;\n",{"version":3,"file":"/Volumes/TamKieu/java/tk-registry/src/main/webapp/app/shared/alert/alert-error.component.ts","sourceRoot":"","sources":["/Volumes/TamKieu/java/tk-registry/node_modules/angular-router-loader/src/index.js!/Volumes/TamKieu/java/tk-registry/node_modules/tslint-loader/index.js!/Volumes/TamKieu/java/tk-registry/src/main/webapp/app/shared/alert/alert-error.component.ts"],"names":[],"mappings":";;;;AAAA,wCAAqD;AACrD,6CAA+D;AAc/D,IAAa,sBAAsB,GAAnC,MAAa,sBAAsB;IAI/B,YAAoB,YAA6B,EAAU,YAA6B;QAApE,iBAAY,GAAZ,YAAY,CAAiB;QAAU,iBAAY,GAAZ,YAAY,CAAiB;QACpF,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QAEjB,IAAI,CAAC,sBAAsB,GAAG,YAAY,CAAC,SAAS,CAAC,+BAA+B,EAAE,QAAQ,CAAC,EAAE;YAC7F,IAAI,CAAC,CAAC;YACN,MAAM,iBAAiB,GAAG,QAAQ,CAAC,OAAO,CAAC;YAC3C,QAAQ,iBAAiB,CAAC,MAAM,EAAE;gBAC9B,2CAA2C;gBAC3C,KAAK,CAAC;oBACF,IAAI,CAAC,aAAa,CAAC,sBAAsB,EAAE,4BAA4B,CAAC,CAAC;oBACzE,MAAM;gBAEV,KAAK,GAAG;oBACJ,MAAM,GAAG,GAAG,iBAAiB,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;oBAC7C,IAAI,WAAW,GAAG,IAAI,CAAC;oBACvB,IAAI,SAAS,GAAG,IAAI,CAAC;oBACrB,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;wBAChB,IAAI,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE;4BAC7B,WAAW,GAAG,iBAAiB,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;yBACtD;6BAAM,IAAI,KAAK,CAAC,QAAQ,CAAC,YAAY,CAAC,EAAE;4BACrC,SAAS,GAAG,iBAAiB,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;yBACpD;oBACL,CAAC,CAAC,CAAC;oBACH,IAAI,WAAW,EAAE;wBACb,MAAM,UAAU,GAAG,SAAS,CAAC;wBAC7B,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,WAAW,EAAE,EAAE,UAAU,EAAE,CAAC,CAAC;qBAChE;yBAAM,IAAI,iBAAiB,CAAC,KAAK,KAAK,EAAE,IAAI,iBAAiB,CAAC,KAAK,CAAC,WAAW,EAAE;wBAC9E,MAAM,WAAW,GAAG,iBAAiB,CAAC,KAAK,CAAC,WAAW,CAAC;wBACxD,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;4BACrC,MAAM,UAAU,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;4BAClC,uGAAuG;4BACvG,MAAM,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;4BAClE,MAAM,SAAS,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;4BACnF,IAAI,CAAC,aAAa,CAAC,QAAQ,GAAG,SAAS,GAAG,kBAAkB,EAAE,QAAQ,GAAG,UAAU,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,CAAC,CAAC;yBAC/G;qBACJ;yBAAM,IAAI,iBAAiB,CAAC,KAAK,KAAK,EAAE,IAAI,iBAAiB,CAAC,IAAI,EAAE,IAAI,iBAAiB,CAAC,KAAK,CAAC,OAAO,EAAE;wBACtG,IAAI,CAAC,aAAa,CACd,iBAAiB,CAAC,KAAK,CAAC,OAAO,EAC/B,iBAAiB,CAAC,KAAK,CAAC,OAAO,EAC/B,iBAAiB,CAAC,KAAK,CAAC,MAAM,CACjC,CAAC;qBACL;yBAAM;wBACH,IAAI,CAAC,aAAa,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;qBAC/C;oBACD,MAAM;gBAEV,KAAK,GAAG;oBACJ,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,qBAAqB,CAAC,CAAC;oBACvD,MAAM;gBAEV;oBACI,IAAI,iBAAiB,CAAC,KAAK,KAAK,EAAE,IAAI,iBAAiB,CAAC,KAAK,CAAC,OAAO,EAAE;wBACnE,IAAI,CAAC,aAAa,CAAC,iBAAiB,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;qBACvD;yBAAM;wBACH,IAAI,CAAC,aAAa,CAAC,iBAAiB,CAAC,KAAK,CAAC,CAAC;qBAC/C;aACR;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAED,WAAW;QACP,IAAI,IAAI,CAAC,sBAAsB,KAAK,SAAS,IAAI,IAAI,CAAC,sBAAsB,KAAK,IAAI,EAAE;YACnF,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC,sBAAsB,CAAC,CAAC;YACvD,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;SACpB;IACL,CAAC;IAED,aAAa,CAAC,OAAO,EAAE,GAAI,EAAE,IAAK;QAC9B,IAAI,CAAC,MAAM,CAAC,IAAI,CACZ,IAAI,CAAC,YAAY,CAAC,QAAQ,CACtB;YACI,IAAI,EAAE,QAAQ;YACd,GAAG,EAAE,OAAO;YACZ,OAAO,EAAE,IAAI;YACb,KAAK,EAAE,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE;YAClC,MAAM,EAAE,IAAI;SACf,EACD,IAAI,CAAC,MAAM,CACd,CACJ,CAAC;IACN,CAAC;CACJ,CAAA;AArFY,sBAAsB;IAXlC,gBAAS,CAAC;QACP,QAAQ,EAAE,iBAAiB;QAC3B,QAAQ,EAAE;;;;;;;eAOC;KACd,CAAC;iEAKoC,6BAAe,oBAAf,6BAAe,oDAAwB,6BAAe,oBAAf,6BAAe;GAJ/E,sBAAsB,CAqFlC;AArFY,wDAAsB","sourcesContent":["import { Component, OnDestroy } from '@angular/core';\nimport { JhiEventManager, JhiAlertService } from 'ng-jhipster';\nimport { Subscription } from 'rxjs/Rx';\n\n@Component({\n    selector: 'jhi-alert-error',\n    template: `\n        <div class=\"alerts\" role=\"alert\">\n            <div *ngFor=\"let alert of alerts\"  [ngClass]=\"{\\'alert.position\\': true, \\'toast\\': alert.toast}\">\n                <ngb-alert *ngIf=\"alert && alert.type && alert.msg\" type=\"{{alert.type}}\" close=\"alert.close(alerts)\">\n                    <pre [innerHTML]=\"alert.msg\"></pre>\n                </ngb-alert>\n            </div>\n        </div>`\n})\nexport class JhiAlertErrorComponent implements OnDestroy {\n    alerts: any[];\n    cleanHttpErrorListener: Subscription;\n\n    constructor(private alertService: JhiAlertService, private eventManager: JhiEventManager) {\n        this.alerts = [];\n\n        this.cleanHttpErrorListener = eventManager.subscribe('jHipsterRegistryApp.httpError', response => {\n            let i;\n            const httpErrorResponse = response.content;\n            switch (httpErrorResponse.status) {\n                // connection refused, server not reachable\n                case 0:\n                    this.addErrorAlert('Server not reachable', 'error.server.not.reachable');\n                    break;\n\n                case 400:\n                    const arr = httpErrorResponse.headers.keys();\n                    let errorHeader = null;\n                    let entityKey = null;\n                    arr.forEach(entry => {\n                        if (entry.endsWith('app-error')) {\n                            errorHeader = httpErrorResponse.headers.get(entry);\n                        } else if (entry.endsWith('app-params')) {\n                            entityKey = httpErrorResponse.headers.get(entry);\n                        }\n                    });\n                    if (errorHeader) {\n                        const entityName = entityKey;\n                        this.addErrorAlert(errorHeader, errorHeader, { entityName });\n                    } else if (httpErrorResponse.error !== '' && httpErrorResponse.error.fieldErrors) {\n                        const fieldErrors = httpErrorResponse.error.fieldErrors;\n                        for (i = 0; i < fieldErrors.length; i++) {\n                            const fieldError = fieldErrors[i];\n                            // convert 'something[14].other[4].id' to 'something[].other[].id' so translations can be written to it\n                            const convertedField = fieldError.field.replace(/\\[\\d*\\]/g, '[]');\n                            const fieldName = convertedField.charAt(0).toUpperCase() + convertedField.slice(1);\n                            this.addErrorAlert('Field ' + fieldName + ' cannot be empty', 'error.' + fieldError.message, { fieldName });\n                        }\n                    } else if (httpErrorResponse.error !== '' && httpErrorResponse.json() && httpErrorResponse.error.message) {\n                        this.addErrorAlert(\n                            httpErrorResponse.error.message,\n                            httpErrorResponse.error.message,\n                            httpErrorResponse.error.params\n                        );\n                    } else {\n                        this.addErrorAlert(httpErrorResponse.error);\n                    }\n                    break;\n\n                case 404:\n                    this.addErrorAlert('Not found', 'error.url.not.found');\n                    break;\n\n                default:\n                    if (httpErrorResponse.error !== '' && httpErrorResponse.error.message) {\n                        this.addErrorAlert(httpErrorResponse.error.message);\n                    } else {\n                        this.addErrorAlert(httpErrorResponse.error);\n                    }\n            }\n        });\n    }\n\n    ngOnDestroy() {\n        if (this.cleanHttpErrorListener !== undefined && this.cleanHttpErrorListener !== null) {\n            this.eventManager.destroy(this.cleanHttpErrorListener);\n            this.alerts = [];\n        }\n    }\n\n    addErrorAlert(message, key?, data?) {\n        this.alerts.push(\n            this.alertService.addAlert(\n                {\n                    type: 'danger',\n                    msg: message,\n                    timeout: 5000,\n                    toast: this.alertService.isToast(),\n                    scoped: true\n                },\n                this.alerts\n            )\n        );\n    }\n}\n"]}]}